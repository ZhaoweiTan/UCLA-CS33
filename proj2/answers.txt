-----------------Qustion 1-------------------------------
Explain why the instructions in the trace did not produce the correct mathematical result. Which instructions caused the problem, exactly?

The correct result will be -2305843009802285360 rather than 2305843008625102544.The result should be obvious: there must be one or more overflow happening in the program leading to incorrect result. 
To find this overflow, I can look at the trace(and also logging) that I left for lab. I tried to find this value, -2305843009802285360 and it did appear in register $rdi, as following: 
Watchpoint 9: $rdi

Old value = -1844255039
New value = -2305843009802285360
0x000000000054799c in arith_driver (code=<optimized out>, nargs=2, args=0x7fffffffd890)
    at data.c:2690
2690		  overflow |= INT_MULTIPLY_WRAPV (accum, next, &accum);
   0x0000000000547998 <arith_driver+456>:	48 0f af fd	imul   %rbp,%rdi
=> 0x000000000054799c <arith_driver+460>:	0f 90 c0	seto   %al
   0x000000000054799f <arith_driver+463>:	48 89 fd	mov    %rdi,%rbp
   0x00000000005479a2 <arith_driver+466>:	41 09 c7	or     %eax,%r15d

The result was generated by above code and then copied into %rbp

Old value = (void *) 0x4a85d2d0
New value = (void *) 0xdfffffffdceaced0
0x00000000005479a2 in arith_driver (code=<optimized out>, nargs=2, args=0x7fffffffd890)
    at data.c:2690
2690		  overflow |= INT_MULTIPLY_WRAPV (accum, next, &accum);
   0x0000000000547998 <arith_driver+456>:	48 0f af fd	imul   %rbp,%rdi
   0x000000000054799c <arith_driver+460>:	0f 90 c0	seto   %al
   0x000000000054799f <arith_driver+463>:	48 89 fd	mov    %rdi,%rbp
=> 0x00000000005479a2 <arith_driver+466>:	41 09 c7	or     %eax,%r15d

However, in the end, what is copied into %rax(return value) is
=> 0x0000000000547920 <arith_driver+336>:	48 8d 04 ad 02 00 00 00	lea    0x2(,%rbp,4),%rax
Watchpoint 4: $rax

Old value = 0
New value = 9223372034500410178
arith_driver (code=Amult, nargs=2, args=0x7fffffffd890) at data.c:2727
2727	}
=> 0x0000000000547928 <arith_driver+344>:	48 83 c4 28	add    $0x28,%rsp

Through such tracing, we find where the problem is: 
	lea    0x2(,%rbp,4),%rax
while rbp is 1101111111111111111111111111111111011100111010101100111011010000
as rbp << 2 will cause an overflow and give a wrong result.

----------------Question 2------------------
Explain why the shell command emacs -Q -batch -eval '(print most-negative-fixnum)' outputs -2305843009213693952. Where did the number come from? Explain in terms of the Emacs source code.

First we need to change this number into hex, which is 0x1FFFFFFFFFFFFFFF. Then all need to do is to find this number in the source code.
In data.c, 
DEFVAR_LISP ("most-positive-fixnum", Vmost_positive_fixnum,
               doc: /* The largest value that is representable in a Lisp integer.  */);

Then we go to lisp.h
#define MOST_POSITIVE_FIXNUM (EMACS_INT_MAX >> INTTYPEBITS)

We know from trace that INTTYPEBITS is 2
because 0x0000000000541da1 <arith_driver+161>lisp.h:701          sar    $0x2,%rdi

It seems self evident that our INT_MAX is 0111111111111111111111111111111111111111111111111111111111111111
and shift right by two and get 
0001111111111111111111111111111111111111111111111111111111111111


--------------Question 3----------------
Explain why the shell command emacs -Q -batch -eval '(print (* most-positive-fixnum most-positive-fixnum most-positive-fixnum most-positive-fixnum))' outputs only 1.


I ran the program by gdb and add watch point to every register, and here is what I find:

0x0000000000541e65 <arith_driver+357>:  48 0f af fb     imul   %rbx,%rdi
Watchpoint 9: $rdi

Old value = 2305843009213693951
New value = -4611686018427387903

0x0000000000541e69 <arith_driver+361>:  48 bb ff ff ff ff ff ff ff 3f   movabs $0x3fffffffffffffff,%rbx
Watchpoint 4: $rbx

Old value = 2305843009213693951
New value = 4611686018427387903

0x0000000000541e73 <arith_driver+371>:  48 21 fb        and    %rdi,%rbx
Watchpoint 4: $rbx

Old value = 4611686018427387903
New value = 1

And the reason behind this result(besides the traces of instruction) is that 
we see from 'lisp.h', when result overflows, the result will be masked by 
(EMACS_INT_MAX >> (INTTYPEBITS - 1))
then what we get from the mask is just 0x00000000..001 and end up with 0x1

-----------------Question 2----------------
The Emacs executable was compiled with GCC's -O2 option. Suppose it had also been compiled with -fwrapv. Explain any problems Emacs would run into, or if there would not be a problem explain why not.

with -fsanitize=undefined flag
we will know the result overflows at run time, because all the operations will go through functions that detects possible undefined behavoiors.

What the trace might run into is more complicated function calls that might make our traces hard to debug or even understand. 
Also there might be performance and efficiency loss of this tag.

------------------
There is a recently-discovered security vulnerability in Emacs 25.2, which you can exercise by running emacs -Q -batch -eval '(print (format-time-string "%Y-%m-%d %H:%M:%S %Z" nil (concat (make-string 1000 ?X) "0")))'. Briefly describe the bug's low-level manifestation by crashing Emacs, using GDB's backtrace command, and following up with any other GDB commands that you think might be of interest.

r -Q -batch -eval '(print (format-time-string "%Y-%m-%d %H:%M:%S %Z" nil (concat (make-string 1000 ?X) "0")))'
and we find the error occurs at the function  __strcpy_sse2_unaligned ()
then 
b  __strcpy_sse2_unaligned
and following the hint by 
backtrace

#0  0x00007ffff173949b in __strcpy_sse2_unaligned () at /lib64/libc.so.6
#1  0x00000000005558f2 in emacs_setenv_TZ (tzstring=0x1483489 'X' <repeats 135 times>, "T", 'X' <repeats 64 times>...)
    at editfns.c:2428
#2  0x00000000005d7f28 in revert_tz (tz=0x1483480) at time_rz.c:223
#3  0x00000000005d7f28 in revert_tz (tz=tz@entry=0x1483480) at time_rz.c:268
#4  0x00000000005d82bc in localtime_rz (tz=0x1483080, t=0x7fffffffc818, tm=0x7fffffffd800) at time_rz.c:289
#5  0x000000000055632a in format_time_string (tm=0x7fffffffc7e0, t=0x7fffffffc818, tz=<optimized out>) at editfns.c:107
#6  0x000000000055632a in format_time_string (format=0x1474d48 "%Y-%m-%d %H:%M:%S %Z", formatlen=20, t=..., zone=zone@entry=21507444, tmp=tmp@entry=0x7fffffffd800) at editfns.c:2070
#7  0x0000000000556582 in Fformat_time_string (format_string=<optimized out>, timeval=<optimized out>, zone=21507444) at editfns.c:2049
#8  0x000000000055ac25 in eval_sub (form=<optimized out>) at eval.c:2178
#9  0x000000000055aa34 in eval_sub (form=form@entry=17131603) at eval.c:2160

....

#22 0x000000000055df7c in Feval (form=17633155, lexical=<optimized out>) at eval.c:1994
#23 0x0000000000559f72 in internal_condition_case (bfun=bfun@entry=0x4ea5f0 <top_level_2>, handlers=handlers@entry=19104, hfun=hfun@entry=0x4eeeb0 <cmd_error>) at eval.c:1315
#24 0x00000000004ecbfc in top_level_1 (ignore=ignore@entry=0) at keyboard.c:1129
#25 0x0000000000559f13 in internal_catch (tag=tag@entry=45936, func=func@entry=0x4ecba0 <top_level_1>, arg=arg@entry=0) at eval.c:1080
#26 0x00000000004ea588 in command_loop () at keyboard.c:1090
#27 0x00000000004eeab7 in recursive_edit_1 () at keyboard.c:697
#28 0x00000000004eedf8 in Frecursive_edit () at keyboard.c:768
#29 0x000000000041907b in main (argc=5, argv=0x7fffffffe308) at emacs.c:1629

then 
b __strcpy_sse2_unaligned
and 
s until reach where the program crashes 
strcpy (tzval + tzeqlen, tzstring);
we reach segmentation fault

Then we run again
info locals 
and I looked up source file to find tzeqlen
found in the second iteration, 
the tzval + tzeqlen's length is more than the length of tzstring
as the copying might trigger canary(or other memory protection mechanism)
and get segmentation fault
